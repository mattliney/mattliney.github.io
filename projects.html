<!DOCTYPE html>
<link rel="stylesheet" href="css/main.css" />
<html>
<head>
    <script type="text/javascript" src="js/main.js"></script>
</head>
<body>
<div class="content">
    <h1>Matthew Liney</h1>
    <a href="index.html" class="my-button">Home</a>
    <a href="projects.html" class="my-button">Projects</a>
    <a href="contact.html" class="my-button">Contact</a>
    <p class="gap"></p>

    <h2>Projects:</h2>

    <!-- SECTION 1 -->

    <div class = "container">

        <div class = "text">
            <p> <b> Honours Stage Project </b></p>
        </div>

        <div >
            <p class="collapse-button" onclick="ToggleCollapseContent('section1')">Show</p>
        </div>

    </div>

    <div class = "collapsible-content" id = "section1">

        <div class = "container">

            <div class = "text">
                <p>For my honours stage project in my final year in university, I tasked myself with researching, designing, and developing a game engine. This also included writing a 15,000 word essay about the subject. I researched the history of game engines and the software methodologies of the past as well as the emerging methods of structuring software. And while the history is quite interesting, the main research and development task of the project was to recreate an entity component system. This was based on the work of game developers around the turn of the century, when MMO games started to gain popularity. They needed a more modern method to develop games, one that was scalable and easy to alter late in development. This new design methodology would come to be known as ECS.</p>
            </div>
    
            <div class="image">
                <img src="images/gamescreeny.png" width="406" height="294" alt="">
              </div>
    
        </div>

        <div class = "container">

            <div class="image" style="margin-top: 2%">
                <img src="images/editor.png" width="406" height="294" alt="">
              </div>

            <div class = "text" style="margin-left: 2%";>
                <p>In short: ECS is a way of structuring your software such that new features can be easily added into the system. This is done mainly by abstracting the system into incredibly small modules, with very few overlapping parts. This results in the game world being built out of these “entities”, which are basically containers of information about what the entity is supposed to represent. These entities are then interpreted by the system, requiring very little actual programming to build a game. I used a C# framework called Monogame and Visual Studio 2022 to create the system. By the end, I had created what I set out to make. A cool game engine, with a cool level editor. I achieved the main feature goals, and implemented the ECS design fairly well, being able to implement entirely new systems seamlessly later in the development. A good first attempt at game engine development overall.</p>
            </div>

            
        </div>

        <p>The code for this project is on my <a href="https://github.com/mattliney/HSP_ECS">Github</a>.</p>

    </div>

    <!-- SECTION 1 END -->

    <p class="gap"></p>

    <!-- SECTION 2 -->

    <div class = "container">

        <div class = "text">
            <p><b> Three Thing Game - Camel Rancher </b></p>
        </div>

        <div >
            <p class="collapse-button" onclick="ToggleCollapseContent('section2')">Show</p>
        </div>

    </div>

    <div class = "collapsible-content" id = "section2">

        <div class = "container">

            <div class = "text">
                <p>Three thing game is a game jam in which the participants must create a game based entirely on three nouns. Myself and three others participated during a Christmas themed version of this competition. Our prompt words were “north pole, camels, and holly. During the initial ideas stage, we came up with the concept of making a farming game, one where the player must take care of camels in the snowy north pole (and also the camels eat holly). I cannot quite remember how, but that idea became a farming game crossed with a twin-stick shooter / survival horror game. The work on the game was divided between me and one other programmer, with the two other team members creating the art assets and writing a convoluted story summary that scrolls vertically in a cinematic opening to the game. The other programmer and I chose to create the game from scratch within the <2 day deadline. It ended up being a fairly gruelling crunch period, but we managed to add in a wealth of not-so-serious features in our not-so-serious game.</p>
            </div>
    
            <div class="image" style="margin-top: 5%;">
                <img src="images/camel.png" width="406" height="294" alt="">
              </div>
    
        </div>

        <div class = "container">

            <div class="image" >
                <img src="images/camel2.png" width="406" height="294" alt="">
              </div>

            <div class = "text" style="margin-left: 2%";>
                <p>We also managed to accrue a large number of cease and desist letters, as we packed the game with a large amount of licensed music. The game development was mainly focused on emphasising the humour of the game. The main gameplay consists of the player spending money on growing and selling holly. They spend this money on camels, the number of camels you acquired would indicate your score at the games’ end. At night, the player has to fend off the elves who attack the farm, a scene which is complete with dramatic music. One feature I insisted on was “The Camel Space”, an impossibly large void within a barn that contains a random assortment of camels based on your current number of camels.</p>
            </div>

            
        </div>

        <p>We ended up <a href="https://threethinggame.com/post/2022-12-07-the-thingmaster-event-results/">winning the competition</a>. You can find the game on <a href="https://mattliney.itch.io/camel-rancher">Itch</a>.</p>

    </div>

    <!-- SECTION 2 END -->

    <p class="gap"></p>

    <!-- SECTION 3 -->

    <div class = "container">

        <div class = "text">
            <p> <b> University Projects</b></p>
        </div>

        <div >
            <p class="collapse-button" onclick="ToggleCollapseContent('section3')">Show</p>
        </div>

    </div>

    <div class = "collapsible-content" id = "section3">

        <div class = "container">

            <div >
                <p>In this section, I am going to describe just two of the many projects I worked on as part of the degree. These were Rust/CUDA particle simulation, and C++ advanced programming. Rust and CUDA was my first attempt at creating multi-threaded software. The goal of the module was to create a particle simulation in both languages respectively. The Rust solution specifically had to be structured in a pipeline. The Rust program was divided into different sections, one for moving the particles and calculating their physics in the air, another for calculating their position on the canvas and drawing it, and so on. Because the particle simulation had to handle hundreds-of-thousands of particles, the program had to be multithreaded. The CUDA program worked similarly. Overall, I enjoyed my work with Rust. It is a fun language to use, and makes multithreading more intuitive. I plan on using it in future projects. CUDA, however, was more cumbersome to use. CUDA is only really used for graphics programming, and can only be used on NVIDIA graphics cards. Before the module began, I had never used Rust or CUDA. Therefore, I had to learn these languages at the same time in a short span of time. Despite this, I ended up getting 84%. In the image, a result of the program running. The particles come from each corner, and land on the canvas. You can see the shape of the spray, the distribution around the canvas, and the blending colours in the middle.</p>
            </div>
    
            <div class="image" style="margin-top: 3%;">
                <img src="images/spray.PNG" width="350" height="350" alt="">
              </div>
    
        </div>

        <div class = "container">

            <div >
                <p>Advanced programming was a C++ module where I had to create a program that read, and solved word searches. It does this by first reading in the puzzle, and a list of the answers. Using this, it can solve any properly formatted puzzle. Sounds easy, but the challenge was not to simply create this. The program had to complete the puzzles within a time limit, the faster the better. It was also being subjected to Parasoft tests, which enforce rules that influence how you program. The penalties applied by parasoft were taken off the final mark. These penalties could be as small as properly following C++ naming conventions, to properly disposing of variables, as C++ does not do this automatically and will cause memory leaks if left unchecked. With this in mind, I scored 97%. Just about as perfect as a C++ program could be.</p>
            </div>
    
            <div>
            </div>
    
        </div>

    </div>

    <!-- SECTION 3 END -->

    <p class="gap"></p>

        <!-- SECTION 4 -->

        <div class = "container">

            <div class = "text">
                <p><b>  Procedural Generation - City Builder</b></p>
            </div>
    
            <div >
                <p class="collapse-button" onclick="ToggleCollapseContent('section4')">Show</p>
            </div>
    
        </div>
    
        
        <div class = "collapsible-content" id = "section4">
    
            <p>Procedural generation is a project I worked on for fun in my own time. I am always quite satisfied when I create a piece of software that results in some kind of graphical display, be it a user interface, or a particle system. In this case, I wanted to implement some fairly simple procedural generation algorithms just to see the results. I initially chose to create a Wave Function Collapse (WFC) program. Turns out, WFC has more to do with quantum mechanics and dead cats than I had originally anticipated. Thankfully no cats were harmed in the creation of the program.
            </p>

            <div class = "container">
    
                <div class="text">
                    <p>WFC works as follows: The map is generated using a set of tiles, an array of initially empty cells, and some adjacency rules. Initially, the cells have a domain size that encompasses all of the tiles. That is to say, the cells can be any one of the tiles. When a cell is collapsed, filled in with one of the tiles, it lowers the domain size of the adjacent cells. In my example, if a cell is collapsed and is given the grass tile, the adjacent tiles can only be grass, water, or a bush. The tree is eliminated from the domain of the adjacent tiles. Initially, a random cell is collapsed, giving it a random tile. From there, the next cell with the smallest domain is collapsed. Repeat until all cells have collapsed. This approach to map creation is fine. I was satisfied when I finally got it to work but, in hindsight, it doesn’t look amazing. Sometimes, the generations look a little bit wonky, and it could never create rivers in a way that satisfied me. Likewise, WFC is vulnerable to error if a domain of a cell is reduced to zero.</p>
                </div>
        
                <div class="image" style="margin-top: 3%;">
                    <img src="images/wfc.gif" width="330" height="240" alt="">
                  </div>
        
            </div>

            <p>Following this, I decided to pick a different algorithm to implement. This was a good decision, as cellular automata is way better. Initially, I created a simple implementation of cellular automata with white tiles on a black background. CA works similarly to WFC, with an array of cells and adjacency rules. Initially, the cells are filled in with random sound. This could be sound ranging from 0 to 1 or a boolean 0 or 1. In my case, I used a boolean. Using the random sound, you iterate through the array, and change tiles based on whats around them. A 1, or land tile, will become a 0, or water tile, if it is surrounded by >4 water tiles. The opposite is also true. This is similar to Conway’s Game of Life.</p>
    
            <div class = "container">
    
                <div class="text" style="margin-top: 5%;">
                    <p>After implementing this with simpler graphics, I immediately saw the potential. The land mass this algorithm creates is ripe for a more advanced graphical implementation, and I immediately got to working on new graphics. No longer simple black and white tiles, I shifted the perspective to an isometric view of the island, and created isometric cube sprites for land and water. This was already looking way better, and I had fun building little scenes with the isometric cubes I drew. Back in the program, I decided to add a second pass to the algorithm, one that populates the map with trees.</p>
                </div>
        
                <div class="image" style="margin-top: 3%;">
                    <img src="images/gen.gif" width="330" height="240" alt="">
                  </div>
        
            </div>

            <p>The next logical step was to add some interactivity. Place houses, farms, shops, and roads that automatically pick the correct sprite based on the adjacent roads. I got really into drawing these little buildings. Finally, I decided to recreate the program in 3D. This concluded the project, as I had started to lose interest by this point. Overall, I think the city builder program is a lot of fun to distract myself with.</p>

            <div class="image" style="margin-top: 3%;">
                <img src="images/build.PNG" width="100%" height="100%" alt="">
              </div>    

            <p>You can build a city too by downloading the program from <a href="https://mattliney.itch.io/city-builder">Itch</a>.</p>

        </div>
    
        <!-- SECTION 4 END -->
    
        <p class="gap"></p>

        <!-- SECTION 5 -->

        <div class = "container">

            <div class = "text">
                <p><b>  Treasure For Two</b></p>
            </div>
    
            <div >
                <p class="collapse-button" onclick="ToggleCollapseContent('section5')">Show</p>
            </div>
    
        </div>
    
        <div class = "collapsible-content" id = "section5">
    
            <div class = "container">
    
                <div >
                    <p>PLACEHOLDERTEXT PLACEHOLDERTEXT PLACEHOLDERTEXT PLACEHOLDERTEXT</p>
                </div>
        
                <div>
                </div>
        
            </div>
    
        </div>
    
        <!-- SECTION 5 END -->
    
        <p class="gap"></p>

</div>
</body>
</html>

<script>

    // add one for each new section
    var visibility = {
        section1: false,
        section2: false,
        section3: false,
        section4: false,
        section5: false,
        section6: false
    }

    function ToggleCollapseContent(sectionID) {

        var content = document.getElementById(sectionID);
        visibility[sectionID] = !visibility[sectionID];

        if(visibility[sectionID])
        {
            content.style.display = "block";
        }
        else
        {
            content.style.display = "none";
        }

    }

</script>
